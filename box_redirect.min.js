import json
import asyncio
import sys
import urllib.parse
import aiohttp.web
import aiohttp
import socket
import re
import configparser

def find_free_port():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0))
        return s.getsockname()[1]

box_device_id_key = "box_device_id"
box_device_id_value = "7e99dafd7a5ffa309d82113cc05360e808cb679b5a8720d55769516ef2c20f3a"
redirect_uri_key = "redirect_uri"
redirect_uri_value = "boxlogin://login"
section_name_list = ("share", "data")

async def handle(request):
    method = request.method
    path = request.path
    path_qs = request.path_qs
    content_type = request.content_type
    sys.stderr.write(f"{method=} {path=} {path_qs=} {content_type=}\n")

    if path == "/authorize":
        assert method == "GET"
        query = dict(request.query)
        sys.stderr.write(f"query original: {json.dumps(query)}\n")
        query[box_device_id_key] = box_device_id_value
        query[redirect_uri_key] = redirect_uri_value
        sys.stderr.write(f"query modified: {json.dumps(query)}\n")
        query_string = urllib.parse.urlencode(query)
        return aiohttp.web.HTTPFound(location="https://account.box.com/api/oauth2/authorize?" + query_string)

    elif path == "/token":
        assert method == "POST"
        assert content_type == "application/x-www-form-urlencoded"
        params = dict(await request.post())
        sys.stderr.write(f"param original: {json.dumps(params)}\n")
        params[box_device_id_key] = box_device_id_value
        params[redirect_uri_key] = redirect_uri_value
        sys.stderr.write(f"param modified: {json.dumps(params)=}\n")
        async with aiohttp.ClientSession() as session:
            async with session.post("https://api.box.com/oauth2/token", data=params) as response:
                sys.stderr.write(f"{response.status=}\n")
                data = await response.content.read()
                sys.stderr.write(f"{data=}\n")
                return aiohttp.web.Response(
                    status=response.status,
                    content_type=response.content_type,
                    body=data,
                )

    else:
        return aiohttp.web.Response(content_type="text/plain", body="hello")

async def get_rclone_config_path():
    process = await asyncio.create_subprocess_exec(
        "rclone", "config", "file",
        stdout=asyncio.subprocess.PIPE,
    )
    stdout = (await process.communicate())[0]
    # print(stdout)

    if process.returncode != 0:
        sys.stderr.write(f"[error] {stderr.decode().strip()}\n")
        return None

    output = stdout.decode().strip()
    
    match = re.search(r"Configuration file is stored at:\s*(.*)", output)

    if match:
        return match.group(1)
    else:
        sys.stderr.write("[error] Failed to parse rclone config path.\n")
        return None

async def setup_runner():
    app = aiohttp.web.Application()
    app.router.add_route('*', '/{tail:.*}', handle)

    runner = aiohttp.web.AppRunner(app)
    await runner.setup()

    port = find_free_port()
    # port = 8080

    rclone_config_path = await get_rclone_config_path()

    config = configparser.ConfigParser()
    config.read(rclone_config_path)

    for section_name in section_name_list:
        if section_name in config:
            config[section_name]["auth_url"] = f"http://127.0.0.1:{port}/authorize"
            config[section_name]["token_url"] = f"http://127.0.0.1:{port}/token"

            with open(rclone_config_path, "w") as configfile:
                config.write(configfile)
            sys.stderr.write("[info] updated rclone config\n")
        else:
            sys.stderr.write("[error] share not found\n")
            raise Exception()

    site = aiohttp.web.TCPSite(runner, "0.0.0.0", port)
    await site.start()
    sys.stderr.write(f"[info] Server running on port {port}\n")

    return runner
    
def main():
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop=loop)
    runner = loop.run_until_complete(setup_runner())
    loop.run_forever()
    
if __name__ == "__main__":
    main()